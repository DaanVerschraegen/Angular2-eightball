{"version":3,"file":"router.umd.js","sources":["../../../../packages/router/src/version.ts","../../../../packages/router/src/router_module.ts","../../../../packages/router/src/router_preloader.ts","../../../../packages/router/src/directives/router_outlet.ts","../../../../packages/router/src/router_outlet_context.ts","../../../../packages/router/src/directives/router_link_active.ts","../../../../packages/router/src/directives/router_link.ts","../../../../packages/router/src/router.ts","../../../../packages/router/src/url_handling_strategy.ts","../../../../packages/router/src/router_config_loader.ts","../../../../packages/router/src/route_reuse_strategy.ts","../../../../packages/router/src/recognize.ts","../../../../packages/router/src/create_url_tree.ts","../../../../packages/router/src/create_router_state.ts","../../../../packages/router/src/router_state.ts","../../../../packages/router/src/utils/tree.ts","../../../../packages/router/src/apply_redirects.ts","../../../../packages/router/src/url_tree.ts","../../../../packages/router/src/utils/collection.ts","../../../../packages/router/src/config.ts","../../../../packages/router/src/shared.ts","../../../../packages/router/src/events.ts","../../../../node_modules/tslib/tslib.es6.js"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n\n\nimport {Version} from '@angular/core';\n/**\n * \\@stable\n */\nexport const VERSION = new Version('4.3.6');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation} from '@angular/common';\nimport {ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Compiler, ComponentRef, Inject, Injectable, InjectionToken, Injector, ModuleWithProviders, NgModule, NgModuleFactoryLoader, NgProbeToken, Optional, Provider, SkipSelf, SystemJsNgModuleLoader} from '@angular/core';\nimport {ÉµgetDOM as getDOM} from '@angular/platform-browser';\nimport {Subject} from 'rxjs/Subject';\nimport {of } from 'rxjs/observable/of';\n\nimport {Route, Routes} from './config';\nimport {RouterLink, RouterLinkWithHref} from './directives/router_link';\nimport {RouterLinkActive} from './directives/router_link_active';\nimport {RouterOutlet} from './directives/router_outlet';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ErrorHandler, Router} from './router';\nimport {ROUTES} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader} from './router_preloader';\nimport {ActivatedRoute} from './router_state';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {DefaultUrlSerializer, UrlSerializer} from './url_tree';\nimport {flatten} from './utils/collection';\n/**\n * \\@whatItDoes Contains a list of directives\n * \\@stable\n */\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n/**\n * \\@whatItDoes Is used in DI to configure the router.\n * \\@stable\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>('ROUTER_CONFIGURATION');\n/**\n * \\@docsNotRequired\n */\nexport const ROUTER_FORROOT_GUARD = new InjectionToken<void>('ROUTER_FORROOT_GUARD');\n\nexport const /** @type {?} */ ROUTER_PROVIDERS: Provider[] = [\n  Location,\n  {provide: UrlSerializer, useClass: DefaultUrlSerializer},\n  {\n    provide: Router,\n    useFactory: setupRouter,\n    deps: [\n      ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector,\n      NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION,\n      [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]\n    ]\n  },\n  ChildrenOutletContexts,\n  {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n  {provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader},\n  RouterPreloader,\n  NoPreloading,\n  PreloadAllModules,\n  {provide: ROUTER_CONFIGURATION, useValue: {enableTracing: false}},\n];\n/**\n * @return {?}\n */\nexport function routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n/**\n * \\@whatItDoes Adds router directives and providers.\n * \n * \\@howToUse \n * \n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n * \n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n * \n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n * \n * When registered at the root, the module should be used as follows\n * \n * ```\n * \\@NgModule({ \n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n * \n * For submodules and lazy loaded submodules the module should be used as follows:\n * \n * ```\n * \\@NgModule({ \n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n * \n * \\@description \n * \n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n * \n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n * \n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n * \n * \\@stable\n */\nexport class RouterModule {\n/**\n * @param {?} guard\n * @param {?} router\n */\nconstructor(  guard: any,  router: Router) {}\n/**\n * Creates a module with all the router providers and directives. It also optionally sets up an\n * application listener to perform an initial navigation.\n * \n * Options:\n * * `enableTracing` makes the router log all its internal events to the console.\n * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n * API.\n * * `initialNavigation` disables the initial navigation.\n * * `errorHandler` provides a custom error handler.\n * @param {?} routes\n * @param {?=} config\n * @return {?}\n */\nstatic forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders {\n    return {\n      ngModule: RouterModule,\n      providers: [\n        ROUTER_PROVIDERS,\n        provideRoutes(routes),\n        {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [[Router, new Optional(), new SkipSelf()]]\n        },\n        {provide: ROUTER_CONFIGURATION, useValue: config ? config : {}},\n        {\n          provide: LocationStrategy,\n          useFactory: provideLocationStrategy,\n          deps: [\n            PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION\n          ]\n        },\n        {\n          provide: PreloadingStrategy,\n          useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                                                             NoPreloading\n        },\n        {provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken},\n        provideRouterInitializer(),\n      ],\n    };\n  }\n/**\n * Creates a module with all the router directives and a provider registering routes.\n * @param {?} routes\n * @return {?}\n */\nstatic forChild(routes: Routes): ModuleWithProviders {\n    return {ngModule: RouterModule, providers: [provideRoutes(routes)]};\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ROUTER_FORROOT_GUARD, ] }, ]},\n{type: Router, decorators: [{ type: Optional }, ]},\n];\n}\n\nfunction RouterModule_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterModule.ctorParameters;\n}\n\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\nexport function provideLocationStrategy(\n    platformLocationStrategy: PlatformLocation, baseHref: string, options: ExtraOptions = {}) {\n  return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :\n                           new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\nexport function provideForRootGuard(router: Router): any {\n  if (router) {\n    throw new Error(\n        `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return 'guarded';\n}\n/**\n * \\@whatItDoes Registers routes.\n * \n * \\@howToUse \n * \n * ```\n * \\@NgModule({ \n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n * \n * \\@stable\n * @param {?} routes\n * @return {?}\n */\nexport function provideRoutes(routes: Routes): any {\n  return [\n    {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes},\n    {provide: ROUTES, multi: true, useValue: routes},\n  ];\n}\n\n/**\n * @whatItDoes Represents an option to configure when the initial navigation is performed.\n *\n * @description\n * * 'enabled' - the initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete.\n * * 'disabled' - the initial navigation is not performed. The location listener is set up before\n * the root component gets created.\n * * 'legacy_enabled'- the initial navigation starts after the root component has been created.\n * The bootstrap is not blocked until the initial navigation is complete. @deprecated\n * * 'legacy_disabled'- the initial navigation is not performed. The location listener is set up\n * after @deprecated\n * the root component gets created.\n * * `true` - same as 'legacy_enabled'. @deprecated since v4\n * * `false` - same as 'legacy_disabled'. @deprecated since v4\n *\n * The 'enabled' option should be used for applications unless there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic. In this case, 'disabled' should be used.\n *\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\n *\n * @experimental\n */\nexport type InitialNavigation =\n    true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\n\n/**\n * @whatItDoes Represents options to configure the router.\n *\n * @stable\n */\nexport interface ExtraOptions {\n  /**\n   * Makes the router log all its internal events to the console.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * Enables the location strategy that uses the URL fragment instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * Disables the initial navigation.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * A custom error handler.\n   */\n  errorHandler?: ErrorHandler;\n\n  /**\n   * Configures a preloading strategy. See {@link PreloadAllModules}.\n   */\n  preloadingStrategy?: any;\n}\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\nexport function setupRouter(\n    ref: ApplicationRef, urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts,\n    location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler,\n    config: Route[][], opts: ExtraOptions = {}, urlHandlingStrategy?: UrlHandlingStrategy,\n    routeReuseStrategy?: RouteReuseStrategy) {\n  const /** @type {?} */ router = new Router(\n      null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.enableTracing) {\n    const /** @type {?} */ dom = getDOM();\n    router.events.subscribe(e => {\n      dom.logGroup(`Router Event: ${( /** @type {?} */((<any>e.constructor))).name}`);\n      dom.log(e.toString());\n      dom.log(e);\n      dom.logGroupEnd();\n    });\n  }\n\n  return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\nexport function rootRoute(router: Router): ActivatedRoute {\n  return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n * \n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n * \n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nexport class RouterInitializer {\nprivate initNavigation: boolean = false;\nprivate resultOfPreactivationDone = new Subject<void>();\n/**\n * @param {?} injector\n */\nconstructor(private injector: Injector) {}\n/**\n * @return {?}\n */\nappInitializer(): Promise<any> {\n    const /** @type {?} */ p: Promise<any> = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n    return p.then(() => {\n      let /** @type {?} */ resolve: Function = /** @type {?} */(( null));\n      const /** @type {?} */ res = new Promise(r => resolve = r);\n      const /** @type {?} */ router = this.injector.get(Router);\n      const /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);\n\n      if (this.isLegacyDisabled(opts) || this.isLegacyEnabled(opts)) {\n        resolve(true);\n\n      } else if (opts.initialNavigation === 'disabled') {\n        router.setUpLocationChangeListener();\n        resolve(true);\n\n      } else if (opts.initialNavigation === 'enabled') {\n        router.hooks.afterPreactivation = () => {\n          // only the initial navigation should be delayed\n          if (!this.initNavigation) {\n            this.initNavigation = true;\n            resolve(true);\n            return this.resultOfPreactivationDone;\n\n            // subsequent navigations should not be delayed\n          } else {\n            return /** @type {?} */(( of (null) as any));\n          }\n        };\n        router.initialNavigation();\n\n      } else {\n        throw new Error(`Invalid initialNavigation options: '${opts.initialNavigation}'`);\n      }\n\n      return res;\n    });\n  }\n/**\n * @param {?} bootstrappedComponentRef\n * @return {?}\n */\nbootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void {\n    const /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);\n    const /** @type {?} */ preloader = this.injector.get(RouterPreloader);\n    const /** @type {?} */ router = this.injector.get(Router);\n    const /** @type {?} */ ref = this.injector.get(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    if (this.isLegacyEnabled(opts)) {\n      router.initialNavigation();\n    } else if (this.isLegacyDisabled(opts)) {\n      router.setUpLocationChangeListener();\n    }\n\n    preloader.setUpPreloading();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    this.resultOfPreactivationDone.next( /** @type {?} */((null)));\n    this.resultOfPreactivationDone.complete();\n  }\n/**\n * @param {?} opts\n * @return {?}\n */\nprivate isLegacyEnabled(opts: ExtraOptions): boolean {\n    return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||\n        opts.initialNavigation === undefined;\n  }\n/**\n * @param {?} opts\n * @return {?}\n */\nprivate isLegacyDisabled(opts: ExtraOptions): boolean {\n    return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n];\n}\n\nfunction RouterInitializer_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterInitializer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterInitializer.ctorParameters;\n/** @type {?} */\nRouterInitializer.prototype.initNavigation;\n/** @type {?} */\nRouterInitializer.prototype.resultOfPreactivationDone;\n/** @type {?} */\nRouterInitializer.prototype.injector;\n}\n\n/**\n * @param {?} r\n * @return {?}\n */\nexport function getAppInitializer(r: RouterInitializer) {\n  return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nexport function getBootstrapListener(r: RouterInitializer) {\n  return r.bootstrapListener.bind(r);\n}\n/**\n * A token for the router initializer that will be called after the app is bootstrapped.\n * \n * \\@experimental\n */\nexport const ROUTER_INITIALIZER =\n    new InjectionToken<(compRef: ComponentRef<any>) => void>('Router Initializer');\n/**\n * @return {?}\n */\nexport function provideRouterInitializer() {\n  return [\n    RouterInitializer,\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      useFactory: getAppInitializer,\n      deps: [RouterInitializer]\n    },\n    {provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer]},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER},\n  ];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\n\n\nimport {Compiler, Injectable, Injector, NgModuleFactoryLoader, NgModuleRef, OnDestroy} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport {from} from 'rxjs/observable/from';\nimport {of } from 'rxjs/observable/of';\nimport {_catch} from 'rxjs/operator/catch';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {filter} from 'rxjs/operator/filter';\nimport {mergeAll} from 'rxjs/operator/mergeAll';\nimport {mergeMap} from 'rxjs/operator/mergeMap';\nimport {LoadedRouterConfig, Route, Routes} from './config';\nimport {Event, NavigationEnd, RouteConfigLoadEnd, RouteConfigLoadStart} from './events';\nimport {Router} from './router';\nimport {RouterConfigLoader} from './router_config_loader';\n/**\n * \\@whatItDoes Provides a preloading strategy.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class PreloadingStrategy {\n/**\n * @abstract\n * @param {?} route\n * @param {?} fn\n * @return {?}\n */\npreload(route: Route, fn: () => Observable<any>) {}\n}\n/**\n * \\@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.\n * \n * \\@howToUse \n * \n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n * \n * \\@experimental\n */\nexport class PreloadAllModules implements PreloadingStrategy {\n/**\n * @param {?} route\n * @param {?} fn\n * @return {?}\n */\npreload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return _catch.call(fn(), () => of (null));\n  }\n}\n/**\n * \\@whatItDoes Provides a preloading strategy that does not preload any modules.\n * \n * \\@description \n * \n * This strategy is enabled by default.\n * \n * \\@experimental\n */\nexport class NoPreloading implements PreloadingStrategy {\n/**\n * @param {?} route\n * @param {?} fn\n * @return {?}\n */\npreload(route: Route, fn: () => Observable<any>): Observable<any> { return of (null); }\n}\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n * \n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n * \n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n * \n * \\@stable\n */\nexport class RouterPreloader implements OnDestroy {\nprivate loader: RouterConfigLoader;\nprivate subscription: Subscription;\n/**\n * @param {?} router\n * @param {?} moduleLoader\n * @param {?} compiler\n * @param {?} injector\n * @param {?} preloadingStrategy\n */\nconstructor(\nprivate router: Router, moduleLoader: NgModuleFactoryLoader, compiler: Compiler,\nprivate injector: Injector,\nprivate preloadingStrategy: PreloadingStrategy) {\n    const onStartLoad = (r: Route) => router.triggerEvent(new RouteConfigLoadStart(r));\n    const onEndLoad = (r: Route) => router.triggerEvent(new RouteConfigLoadEnd(r));\n\n    this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n  };\n/**\n * @return {?}\n */\nsetUpPreloading(): void {\n    const /** @type {?} */ navigations$ = filter.call(this.router.events, (e: Event) => e instanceof NavigationEnd);\n    this.subscription = concatMap.call(navigations$, () => this.preload()).subscribe(() => {});\n  }\n/**\n * @return {?}\n */\npreload(): Observable<any> {\n    const /** @type {?} */ ngModule = this.injector.get(NgModuleRef);\n    return this.processRoutes(ngModule, this.router.config);\n  }\n/**\n * @return {?}\n */\nngOnDestroy(): void { this.subscription.unsubscribe(); }\n/**\n * @param {?} ngModule\n * @param {?} routes\n * @return {?}\n */\nprivate processRoutes(ngModule: NgModuleRef<any>, routes: Routes): Observable<void> {\n    const /** @type {?} */ res: Observable<any>[] = [];\n    for (const /** @type {?} */ route of routes) {\n      // we already have the config loaded, just recurse\n      if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n        const /** @type {?} */ childConfig = route._loadedConfig;\n        res.push(this.processRoutes(childConfig.module, childConfig.routes));\n\n        // no config loaded, fetch the config\n      } else if (route.loadChildren && !route.canLoad) {\n        res.push(this.preloadConfig(ngModule, route));\n\n        // recurse into children\n      } else if (route.children) {\n        res.push(this.processRoutes(ngModule, route.children));\n      }\n    }\n    return mergeAll.call(from(res));\n  }\n/**\n * @param {?} ngModule\n * @param {?} route\n * @return {?}\n */\nprivate preloadConfig(ngModule: NgModuleRef<any>, route: Route): Observable<void> {\n    return this.preloadingStrategy.preload(route, () => {\n      const /** @type {?} */ loaded$ = this.loader.load(ngModule.injector, route);\n      return mergeMap.call(loaded$, (config: LoadedRouterConfig) => {\n        route._loadedConfig = config;\n        return this.processRoutes(config.module, config.routes);\n      });\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Router, },\n{type: NgModuleFactoryLoader, },\n{type: Compiler, },\n{type: Injector, },\n{type: PreloadingStrategy, },\n];\n}\n\nfunction RouterPreloader_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterPreloader.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterPreloader.ctorParameters;\n/** @type {?} */\nRouterPreloader.prototype.loader;\n/** @type {?} */\nRouterPreloader.prototype.subscription;\n/** @type {?} */\nRouterPreloader.prototype.router;\n/** @type {?} */\nRouterPreloader.prototype.injector;\n/** @type {?} */\nRouterPreloader.prototype.preloadingStrategy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Attribute, ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, Directive, EventEmitter, Injector, OnDestroy, OnInit, Output, ViewContainerRef} from '@angular/core';\n\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n/**\n * \\@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n * state.\n * \n * \\@howToUse \n * \n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n * \n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n * \n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n * \n * \\@stable\n */\nexport class RouterOutlet implements OnDestroy, OnInit {\nprivate activated: ComponentRef<any>|null = null;\nprivate _activatedRoute: ActivatedRoute|null = null;\nprivate name: string;\n\n   activateEvents = new EventEmitter<any>();\n   deactivateEvents = new EventEmitter<any>();\n/**\n * @param {?} parentContexts\n * @param {?} location\n * @param {?} resolver\n * @param {?} name\n * @param {?} changeDetector\n */\nconstructor(\nprivate parentContexts: ChildrenOutletContexts,\nprivate location: ViewContainerRef,\nprivate resolver: ComponentFactoryResolver,  name: string,\nprivate changeDetector: ChangeDetectorRef) {\n    this.name = name || PRIMARY_OUTLET;\n    parentContexts.onChildOutletCreated(this.name, this);\n  }\n/**\n * @return {?}\n */\nngOnDestroy(): void { this.parentContexts.onChildOutletDestroyed(this.name); }\n/**\n * @return {?}\n */\nngOnInit(): void {\n    if (!this.activated) {\n      // If the outlet was not instantiated at the time the route got activated we need to populate\n      // the outlet when it is initialized (ie inside a NgIf)\n      const /** @type {?} */ context = this.parentContexts.getContext(this.name);\n      if (context && context.route) {\n        if (context.attachRef) {\n          // `attachRef` is populated when there is an existing component to mount\n          this.attach(context.attachRef, context.route);\n        } else {\n          // otherwise the component defined in the configuration is created\n          this.activateWith(context.route, context.resolver || null);\n        }\n      }\n    }\n  }\n/**\n * @deprecated since v4 *\n * @return {?}\n */\nget locationInjector(): Injector { return this.location.injector; }\n/**\n * @deprecated since v4 *\n * @return {?}\n */\nget locationFactoryResolver(): ComponentFactoryResolver { return this.resolver; }\n/**\n * @return {?}\n */\nget isActivated(): boolean { return !!this.activated; }\n/**\n * @return {?}\n */\nget component(): Object {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    return this.activated.instance;\n  }\n/**\n * @return {?}\n */\nget activatedRoute(): ActivatedRoute {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    return /** @type {?} */(( this._activatedRoute as ActivatedRoute));\n  }\n/**\n * @return {?}\n */\nget activatedRouteData() {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n/**\n * Called when the `RouteReuseStrategy` instructs to detach the subtree\n * @return {?}\n */\ndetach(): ComponentRef<any> {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    this.location.detach();\n    const /** @type {?} */ cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    return cmp;\n  }\n/**\n * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n * @param {?} ref\n * @param {?} activatedRoute\n * @return {?}\n */\nattach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n  }\n/**\n * @return {?}\n */\ndeactivate(): void {\n    if (this.activated) {\n      const /** @type {?} */ c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n/**\n * @param {?} activatedRoute\n * @param {?} resolver\n * @return {?}\n */\nactivateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver|null) {\n    if (this.isActivated) {\n      throw new Error('Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    const /** @type {?} */ snapshot = activatedRoute._futureSnapshot;\n    const /** @type {?} */ component = /** @type {?} */(( <any> /** @type {?} */((snapshot._routeConfig)).component));\n    resolver = resolver || this.resolver;\n    const /** @type {?} */ factory = resolver.resolveComponentFactory(component);\n    const /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n    this.activated = this.location.createComponent(factory, this.location.length, injector);\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.activateEvents.emit(this.activated.instance);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{selector: 'router-outlet', exportAs: 'outlet'}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChildrenOutletContexts, },\n{type: ViewContainerRef, },\n{type: ComponentFactoryResolver, },\n{type: undefined, decorators: [{ type: Attribute, args: ['name', ] }, ]},\n{type: ChangeDetectorRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'activateEvents': [{ type: Output, args: ['activate', ] },],\n'deactivateEvents': [{ type: Output, args: ['deactivate', ] },],\n};\n}\n\nfunction RouterOutlet_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterOutlet.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterOutlet.ctorParameters;\n/** @type {?} */\nRouterOutlet.propDecorators;\n/** @type {?} */\nRouterOutlet.prototype.activated;\n/** @type {?} */\nRouterOutlet.prototype._activatedRoute;\n/** @type {?} */\nRouterOutlet.prototype.name;\n/** @type {?} */\nRouterOutlet.prototype.activateEvents;\n/** @type {?} */\nRouterOutlet.prototype.deactivateEvents;\n/** @type {?} */\nRouterOutlet.prototype.parentContexts;\n/** @type {?} */\nRouterOutlet.prototype.location;\n/** @type {?} */\nRouterOutlet.prototype.resolver;\n/** @type {?} */\nRouterOutlet.prototype.changeDetector;\n}\n\nclass OutletInjector implements Injector {\n/**\n * @param {?} route\n * @param {?} childContexts\n * @param {?} parent\n */\nconstructor(\nprivate route: ActivatedRoute,\nprivate childContexts: ChildrenOutletContexts,\nprivate parent: Injector) {}\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nfunction OutletInjector_tsickle_Closure_declarations() {\n/** @type {?} */\nOutletInjector.prototype.route;\n/** @type {?} */\nOutletInjector.prototype.childContexts;\n/** @type {?} */\nOutletInjector.prototype.parent;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ComponentFactoryResolver, ComponentRef} from '@angular/core';\n\nimport {RouterOutlet} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\n/**\n * Store contextual information about a {\\@link RouterOutlet}\n * \n * \\@stable\n */\nexport class OutletContext {\n  outlet: RouterOutlet|null = null;\n  route: ActivatedRoute|null = null;\n  resolver: ComponentFactoryResolver|null = null;\n  children = new ChildrenOutletContexts();\n  attachRef: ComponentRef<any>|null = null;\n}\n\nfunction OutletContext_tsickle_Closure_declarations() {\n/** @type {?} */\nOutletContext.prototype.outlet;\n/** @type {?} */\nOutletContext.prototype.route;\n/** @type {?} */\nOutletContext.prototype.resolver;\n/** @type {?} */\nOutletContext.prototype.children;\n/** @type {?} */\nOutletContext.prototype.attachRef;\n}\n\n/**\n * Store contextual information about the children (= nested) {\\@link RouterOutlet}\n * \n * \\@stable\n */\nexport class ChildrenOutletContexts {\nprivate contexts = new Map<string, OutletContext>();\n/**\n * Called when a `RouterOutlet` directive is instantiated\n * @param {?} childName\n * @param {?} outlet\n * @return {?}\n */\nonChildOutletCreated(childName: string, outlet: RouterOutlet): void {\n    const /** @type {?} */ context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n/**\n * Called when a `RouterOutlet` directive is destroyed.\n * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n * re-created later.\n * @param {?} childName\n * @return {?}\n */\nonChildOutletDestroyed(childName: string): void {\n    const /** @type {?} */ context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n    }\n  }\n/**\n * Called when the corresponding route is deactivated during navigation.\n * Because the component get destroyed, all children outlet are destroyed.\n * @return {?}\n */\nonOutletDeactivated(): Map<string, OutletContext> {\n    const /** @type {?} */ contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n/**\n * @param {?} contexts\n * @return {?}\n */\nonOutletReAttached(contexts: Map<string, OutletContext>) { this.contexts = contexts; }\n/**\n * @param {?} childName\n * @return {?}\n */\ngetOrCreateContext(childName: string): OutletContext {\n    let /** @type {?} */ context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext();\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n/**\n * @param {?} childName\n * @return {?}\n */\ngetContext(childName: string): OutletContext|null { return this.contexts.get(childName) || null; }\n}\n\nfunction ChildrenOutletContexts_tsickle_Closure_declarations() {\n/** @type {?} */\nChildrenOutletContexts.prototype.contexts;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AfterContentInit, ChangeDetectorRef, ContentChildren, Directive, ElementRef, Input, OnChanges, OnDestroy, QueryList, Renderer2, SimpleChanges} from '@angular/core';\nimport {Subscription} from 'rxjs/Subscription';\nimport {NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {RouterLink, RouterLinkWithHref} from './router_link';\n/**\n * \\@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n * \n * \\@howToUse \n * \n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n * \n * \\@description \n * \n * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n * becomes active.\n * \n * Consider the following example:\n * \n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n * \n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n * \n * You can set more than one class, as follows:\n * \n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n * \n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n * \n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n * \n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n * \n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n * \n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n * \n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n * \n * \\@ngModule RouterModule\n * \n * \\@stable\n */\nexport class RouterLinkActive implements OnChanges,\n    OnDestroy, AfterContentInit {\n   links: QueryList<RouterLink>;\n  \n  linksWithHrefs: QueryList<RouterLinkWithHref>;\nprivate classes: string[] = [];\nprivate subscription: Subscription;\nprivate active: boolean = false;\n\n   routerLinkActiveOptions: {exact: boolean} = {exact: false};\n/**\n * @param {?} router\n * @param {?} element\n * @param {?} renderer\n * @param {?} cdr\n */\nconstructor(\nprivate router: Router,\nprivate element: ElementRef,\nprivate renderer: Renderer2,\nprivate cdr: ChangeDetectorRef) {\n    this.subscription = router.events.subscribe(s => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n/**\n * @return {?}\n */\nget isActive(): boolean { return this.active; }\n/**\n * @return {?}\n */\nngAfterContentInit(): void {\n    this.links.changes.subscribe(_ => this.update());\n    this.linksWithHrefs.changes.subscribe(_ => this.update());\n    this.update();\n  }\n/**\n * @param {?} data\n * @return {?}\n */\nset routerLinkActive(data: string[]|string) {\n    const /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');\n    this.classes = classes.filter(c => !!c);\n  }\n/**\n * @param {?} changes\n * @return {?}\n */\nngOnChanges(changes: SimpleChanges): void { this.update(); }\n/**\n * @return {?}\n */\nngOnDestroy(): void { this.subscription.unsubscribe(); }\n/**\n * @return {?}\n */\nprivate update(): void {\n    if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n    const /** @type {?} */ hasActiveLinks = this.hasActiveLinks();\n\n    // react only when status has changed to prevent unnecessary dom updates\n    if (this.active !== hasActiveLinks) {\n      this.classes.forEach((c) => {\n        if (hasActiveLinks) {\n          this.renderer.addClass(this.element.nativeElement, c);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, c);\n        }\n      });\n      Promise.resolve(hasActiveLinks).then(active => this.active = active);\n    }\n  }\n/**\n * @param {?} router\n * @return {?}\n */\nprivate isLinkActive(router: Router): (link: (RouterLink|RouterLinkWithHref)) => boolean {\n    return (link: RouterLink | RouterLinkWithHref) =>\n               router.isActive(link.urlTree, this.routerLinkActiveOptions.exact);\n  }\n/**\n * @return {?}\n */\nprivate hasActiveLinks(): boolean {\n    return this.links.some(this.isLinkActive(this.router)) ||\n        this.linksWithHrefs.some(this.isLinkActive(this.router));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[routerLinkActive]',\n  exportAs: 'routerLinkActive',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Router, },\n{type: ElementRef, },\n{type: Renderer2, },\n{type: ChangeDetectorRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'links': [{ type: ContentChildren, args: [RouterLink, {descendants: true}, ] },],\n'linksWithHrefs': [{ type: ContentChildren, args: [RouterLinkWithHref, {descendants: true}, ] },],\n'routerLinkActiveOptions': [{ type: Input },],\n'routerLinkActive': [{ type: Input },],\n};\n}\n\nfunction RouterLinkActive_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterLinkActive.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterLinkActive.ctorParameters;\n/** @type {?} */\nRouterLinkActive.propDecorators;\n/** @type {?} */\nRouterLinkActive.prototype.links;\n/** @type {?} */\nRouterLinkActive.prototype.linksWithHrefs;\n/** @type {?} */\nRouterLinkActive.prototype.classes;\n/** @type {?} */\nRouterLinkActive.prototype.subscription;\n/** @type {?} */\nRouterLinkActive.prototype.active;\n/** @type {?} */\nRouterLinkActive.prototype.routerLinkActiveOptions;\n/** @type {?} */\nRouterLinkActive.prototype.router;\n/** @type {?} */\nRouterLinkActive.prototype.element;\n/** @type {?} */\nRouterLinkActive.prototype.renderer;\n/** @type {?} */\nRouterLinkActive.prototype.cdr;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {LocationStrategy} from '@angular/common';\nimport {Attribute, Directive, ElementRef, HostBinding, HostListener, Input, OnChanges, OnDestroy, Renderer2, isDevMode} from '@angular/core';\nimport {Subscription} from 'rxjs/Subscription';\n\nimport {QueryParamsHandling} from '../config';\nimport {NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {ActivatedRoute} from '../router_state';\nimport {UrlTree} from '../url_tree';\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n * \n * \\@howToUse \n * \n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`\n * \n * When linking to this `user/:name` route, you can write:\n * `<a routerLink='/user/bob'>link to user component</a>`\n * \n * \\@description \n * \n * The RouterLink directives let you link to specific parts of your app.\n * \n * When the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n * \n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n * \n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n * \n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n * \n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n * \n * You can set query params and fragment as follows:\n * \n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n * \n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n * \n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n * \n * You can tell the directive to how to handle queryParams, available options are:\n *  - 'merge' merge the queryParams into the current queryParams\n *  - 'preserve' preserve the current queryParams\n *  - default / '' use the queryParams only\n *  same options for {\\@link NavigationExtras#queryParamsHandling}\n * \n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n * \n * The router link directive always treats the provided input as a delta to the current url.\n * \n * For instance, if the current url is `/user/(box//aux:team)`.\n * \n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n * \n * \\@ngModule RouterModule\n * \n * See {\\@link Router#createUrlTree} for more information.\n * \n * \\@stable\n */\nexport class RouterLink {\n   queryParams: {[k: string]: any};\n   fragment: string;\n   queryParamsHandling: QueryParamsHandling;\n   preserveFragment: boolean;\n   skipLocationChange: boolean;\n   replaceUrl: boolean;\nprivate commands: any[] = [];\nprivate preserve: boolean;\n/**\n * @param {?} router\n * @param {?} route\n * @param {?} tabIndex\n * @param {?} renderer\n * @param {?} el\n */\nconstructor(\nprivate router: Router,\nprivate route: ActivatedRoute,\n       tabIndex: string, renderer: Renderer2, el: ElementRef) {\n    if (tabIndex == null) {\n      renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n    }\n  }\n/**\n * @param {?} commands\n * @return {?}\n */\nset routerLink(commands: any[]|string) {\n    if (commands != null) {\n      this.commands = Array.isArray(commands) ? commands : [commands];\n    } else {\n      this.commands = [];\n    }\n  }\n/**\n * @deprecated 4.0.0 use `queryParamsHandling` instead.\n * @param {?} value\n * @return {?}\n */\nset preserveQueryParams(value: boolean) {\n    if (isDevMode() && /** @type {?} */(( <any>console)) && /** @type {?} */(( <any>console.warn))) {\n      console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n    }\n    this.preserve = value;\n  }\n/**\n * @return {?}\n */\nonClick(): boolean {\n    const /** @type {?} */ extras = {\n      skipLocationChange: attrBoolValue(this.skipLocationChange),\n      replaceUrl: attrBoolValue(this.replaceUrl),\n    };\n    this.router.navigateByUrl(this.urlTree, extras);\n    return true;\n  }\n/**\n * @return {?}\n */\nget urlTree(): UrlTree {\n    return this.router.createUrlTree(this.commands, {\n      relativeTo: this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      preserveQueryParams: attrBoolValue(this.preserve),\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: attrBoolValue(this.preserveFragment),\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{selector: ':not(a)[routerLink]'}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Router, },\n{type: ActivatedRoute, },\n{type: undefined, decorators: [{ type: Attribute, args: ['tabindex', ] }, ]},\n{type: Renderer2, },\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'queryParams': [{ type: Input },],\n'fragment': [{ type: Input },],\n'queryParamsHandling': [{ type: Input },],\n'preserveFragment': [{ type: Input },],\n'skipLocationChange': [{ type: Input },],\n'replaceUrl': [{ type: Input },],\n'routerLink': [{ type: Input },],\n'preserveQueryParams': [{ type: Input },],\n'onClick': [{ type: HostListener, args: ['click', ] },],\n};\n}\n\nfunction RouterLink_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterLink.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterLink.ctorParameters;\n/** @type {?} */\nRouterLink.propDecorators;\n/** @type {?} */\nRouterLink.prototype.queryParams;\n/** @type {?} */\nRouterLink.prototype.fragment;\n/** @type {?} */\nRouterLink.prototype.queryParamsHandling;\n/** @type {?} */\nRouterLink.prototype.preserveFragment;\n/** @type {?} */\nRouterLink.prototype.skipLocationChange;\n/** @type {?} */\nRouterLink.prototype.replaceUrl;\n/** @type {?} */\nRouterLink.prototype.commands;\n/** @type {?} */\nRouterLink.prototype.preserve;\n/** @type {?} */\nRouterLink.prototype.router;\n/** @type {?} */\nRouterLink.prototype.route;\n}\n\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n * \n * See {\\@link RouterLink} for more information.\n * \n * \\@ngModule RouterModule\n * \n * \\@stable\n */\nexport class RouterLinkWithHref implements OnChanges, OnDestroy {\n    target: string;\n   queryParams: {[k: string]: any};\n   fragment: string;\n   queryParamsHandling: QueryParamsHandling;\n   preserveFragment: boolean;\n   skipLocationChange: boolean;\n   replaceUrl: boolean;\nprivate commands: any[] = [];\nprivate subscription: Subscription;\nprivate preserve: boolean;\n\n  // the url displayed on the anchor element.\n   href: string;\n/**\n * @param {?} router\n * @param {?} route\n * @param {?} locationStrategy\n */\nconstructor(\nprivate router: Router,\nprivate route: ActivatedRoute,\nprivate locationStrategy: LocationStrategy) {\n    this.subscription = router.events.subscribe(s => {\n      if (s instanceof NavigationEnd) {\n        this.updateTargetUrlAndHref();\n      }\n    });\n  }\n/**\n * @param {?} commands\n * @return {?}\n */\nset routerLink(commands: any[]|string) {\n    if (commands != null) {\n      this.commands = Array.isArray(commands) ? commands : [commands];\n    } else {\n      this.commands = [];\n    }\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nset preserveQueryParams(value: boolean) {\n    if (isDevMode() && /** @type {?} */(( <any>console)) && /** @type {?} */(( <any>console.warn))) {\n      console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n    }\n    this.preserve = value;\n  }\n/**\n * @param {?} changes\n * @return {?}\n */\nngOnChanges(changes: {}): any { this.updateTargetUrlAndHref(); }\n/**\n * @return {?}\n */\nngOnDestroy(): any { this.subscription.unsubscribe(); }\n/**\n * @param {?} button\n * @param {?} ctrlKey\n * @param {?} metaKey\n * @param {?} shiftKey\n * @return {?}\n */\nonClick(button: number, ctrlKey: boolean, metaKey: boolean, shiftKey: boolean): boolean {\n    if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n      return true;\n    }\n\n    if (typeof this.target === 'string' && this.target != '_self') {\n      return true;\n    }\n\n    const /** @type {?} */ extras = {\n      skipLocationChange: attrBoolValue(this.skipLocationChange),\n      replaceUrl: attrBoolValue(this.replaceUrl),\n    };\n    this.router.navigateByUrl(this.urlTree, extras);\n    return false;\n  }\n/**\n * @return {?}\n */\nprivate updateTargetUrlAndHref(): void {\n    this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n  }\n/**\n * @return {?}\n */\nget urlTree(): UrlTree {\n    return this.router.createUrlTree(this.commands, {\n      relativeTo: this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      preserveQueryParams: attrBoolValue(this.preserve),\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: attrBoolValue(this.preserveFragment),\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{selector: 'a[routerLink]'}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Router, },\n{type: ActivatedRoute, },\n{type: LocationStrategy, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'target': [{ type: HostBinding, args: ['attr.target', ] },{ type: Input },],\n'queryParams': [{ type: Input },],\n'fragment': [{ type: Input },],\n'queryParamsHandling': [{ type: Input },],\n'preserveFragment': [{ type: Input },],\n'skipLocationChange': [{ type: Input },],\n'replaceUrl': [{ type: Input },],\n'href': [{ type: HostBinding },],\n'routerLink': [{ type: Input },],\n'preserveQueryParams': [{ type: Input },],\n'onClick': [{ type: HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'], ] },],\n};\n}\n\nfunction RouterLinkWithHref_tsickle_Closure_declarations() {\n/** @type {?} */\nRouterLinkWithHref.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nRouterLinkWithHref.ctorParameters;\n/** @type {?} */\nRouterLinkWithHref.propDecorators;\n/** @type {?} */\nRouterLinkWithHref.prototype.target;\n/** @type {?} */\nRouterLinkWithHref.prototype.queryParams;\n/** @type {?} */\nRouterLinkWithHref.prototype.fragment;\n/** @type {?} */\nRouterLinkWithHref.prototype.queryParamsHandling;\n/** @type {?} */\nRouterLinkWithHref.prototype.preserveFragment;\n/** @type {?} */\nRouterLinkWithHref.prototype.skipLocationChange;\n/** @type {?} */\nRouterLinkWithHref.prototype.replaceUrl;\n/** @type {?} */\nRouterLinkWithHref.prototype.commands;\n/** @type {?} */\nRouterLinkWithHref.prototype.subscription;\n/** @type {?} */\nRouterLinkWithHref.prototype.preserve;\n/** @type {?} */\nRouterLinkWithHref.prototype.href;\n/** @type {?} */\nRouterLinkWithHref.prototype.router;\n/** @type {?} */\nRouterLinkWithHref.prototype.route;\n/** @type {?} */\nRouterLinkWithHref.prototype.locationStrategy;\n}\n\n/**\n * @param {?} s\n * @return {?}\n */\nfunction attrBoolValue(s: any): boolean {\n  return s === '' || !!s;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Location} from '@angular/common';\nimport {Compiler, Injector, NgModuleFactoryLoader, NgModuleRef, Type, isDevMode} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\nimport {Subscription} from 'rxjs/Subscription';\nimport {from} from 'rxjs/observable/from';\nimport {of } from 'rxjs/observable/of';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {every} from 'rxjs/operator/every';\nimport {first} from 'rxjs/operator/first';\nimport {last} from 'rxjs/operator/last';\nimport {map} from 'rxjs/operator/map';\nimport {mergeMap} from 'rxjs/operator/mergeMap';\nimport {reduce} from 'rxjs/operator/reduce';\n\nimport {applyRedirects} from './apply_redirects';\nimport {LoadedRouterConfig, QueryParamsHandling, ResolveData, Route, Routes, RunGuardsAndResolvers, validateConfig} from './config';\nimport {createRouterState} from './create_router_state';\nimport {createUrlTree} from './create_url_tree';\nimport {Event, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized} from './events';\nimport {recognize} from './recognize';\nimport {DefaultRouteReuseStrategy, DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts, OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, advanceActivatedRoute, createEmptyState, equalParamsAndUrlSegments, inheritedParamsDataResolve} from './router_state';\nimport {Params, isNavigationCancelingError} from './shared';\nimport {DefaultUrlHandlingStrategy, UrlHandlingStrategy} from './url_handling_strategy';\nimport {UrlSerializer, UrlTree, containsTree, createEmptyUrlTree} from './url_tree';\nimport {andObservables, forEach, shallowEqual, waitForMap, wrapIntoObservable} from './utils/collection';\nimport {TreeNode} from './utils/tree';\n\ndeclare let Zone: any;\n\n/**\n * @whatItDoes Represents the extra options used during navigation.\n *\n * @stable\n */\nexport interface NavigationExtras {\n  /**\n  * Enables relative navigation from the current ActivatedRoute.\n  *\n  * Configuration:\n  *\n  * ```\n  * [{\n  *   path: 'parent',\n  *   component: ParentComponent,\n  *   children: [{\n  *     path: 'list',\n  *     component: ListComponent\n  *   },{\n  *     path: 'child',\n  *     component: ChildComponent\n  *   }]\n  * }]\n  * ```\n  *\n  * Navigate to list route from child route:\n  *\n  * ```\n  *  @Component({...})\n  *  class ChildComponent {\n  *    constructor(private router: Router, private route: ActivatedRoute) {}\n  *\n  *    go() {\n  *      this.router.navigate(['../list'], { relativeTo: this.route });\n  *    }\n  *  }\n  * ```\n  */\n  relativeTo?: ActivatedRoute|null;\n\n  /**\n  * Sets query parameters to the URL.\n  *\n  * ```\n  * // Navigate to /results?page=1\n  * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n  * ```\n  */\n  queryParams?: Params|null;\n\n  /**\n  * Sets the hash fragment for the URL.\n  *\n  * ```\n  * // Navigate to /results#top\n  * this.router.navigate(['/results'], { fragment: 'top' });\n  * ```\n  */\n  fragment?: string;\n\n  /**\n  * Preserves the query parameters for the next navigation.\n  *\n  * deprecated, use `queryParamsHandling` instead\n  *\n  * ```\n  * // Preserve query params from /results?page=1 to /view?page=1\n  * this.router.navigate(['/view'], { preserveQueryParams: true });\n  * ```\n  *\n  * @depre